<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>气体巨行星贴图生成器 | Gas Giant Texture Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Simplex Noise 库 -->
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@3.0.1/dist/simplex-noise.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            background-image: repeating-conic-gradient(#333 0% 25%, #444 0% 50%);
            background-size: 20px 20px;
        }
        #spinner {
            display: inline-block;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-gray-800/50 rounded-2xl shadow-2xl p-6 sm:p-8 backdrop-blur-sm border border-gray-700">
        <div class="text-center">
            <h1 class="text-2xl sm:text-3xl font-bold text-white tracking-tight">气体巨行星贴图生成器</h1>
            <p class="text-gray-400 mt-2 mb-6">程序化生成无缝平铺的气体巨行星纹理。</p>
        </div>

        <!-- 控制选项 -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
            <div>
                <label for="resolution" class="block text-sm font-medium text-gray-300 mb-1">分辨率</label>
                <select id="resolution" class="w-full bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="1k">1K (1024x512)</option>
                    <option value="2k">2K (2048x1024)</option>
                </select>
            </div>
            <div>
                <label for="palette" class="block text-sm font-medium text-gray-300 mb-1">调色板</label>
                <select id="palette" class="w-full bg-gray-700 border border-gray-600 text-white rounded-md p-2 focus:ring-indigo-500 focus:border-indigo-500">
                    <option value="random">随机</option>
                    <!-- 选项会由JS动态填充 -->
                </select>
            </div>
            <div class="flex items-end justify-center">
                <div class="flex items-center">
                    <input id="greatStorm" type="checkbox" checked class="h-4 w-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500">
                    <label for="greatStorm" class="ml-2 text-sm font-medium text-gray-300">生成大红斑风暴</label>
                </div>
            </div>
        </div>
        
        <!-- 预览和按钮 -->
        <div class="canvas-container w-full aspect-[2/1] bg-gray-900/50 rounded-lg overflow-hidden border border-gray-700 flex items-center justify-center mb-6">
            <canvas id="planetCanvas"></canvas>
        </div>

        <div class="flex flex-col sm:flex-row gap-4 justify-center">
            <button id="generateBtn" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-500 text-white font-semibold py-3 px-6 rounded-lg transition-all duration-200 shadow-lg focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-offset-2 focus:ring-offset-gray-900 flex items-center justify-center">
                <span id="btnText">生成贴图</span>
                <span id="spinner" class="hidden w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin ml-2"></span>
            </button>
            <a id="downloadLink" class="w-full sm:w-auto bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg transition-all duration-200 hidden cursor-pointer text-center">
                下载 PNG
            </a>
        </div>
        <p id="statusText" class="text-gray-500 text-sm mt-4 h-5 text-center"></p>
        <p class="text-xs text-gray-600 mt-2 text-center">注意: 这是一个计算密集型任务，尤其在 2K 分辨率下可能会导致浏览器卡顿。</p>
    </div>

    <script>
        // --- DOM Elements ---
        const resolutionSelect = document.getElementById('resolution');
        const paletteSelect = document.getElementById('palette');
        const greatStormCheckbox = document.getElementById('greatStorm');
        const canvas = document.getElementById('planetCanvas');
        const ctx = canvas.getContext('2d');
        const generateBtn = document.getElementById('generateBtn');
        const downloadLink = document.getElementById('downloadLink');
        const statusText = document.getElementById('statusText');
        const btnText = document.getElementById('btnText');
        const spinner = document.getElementById('spinner');

        // --- Palettes ---
        const PALETTES = {
            "astral_haze": [[101, 98, 116], [109, 116, 137], [210, 174, 192], [182, 210, 173], [50, 80, 140], [10, 30, 70]],
            "icy_neptune": [[50, 80, 150], [80, 120, 200], [30, 50, 100], [180, 200, 240], [72, 93, 108], [167, 237, 255]],
            "golden_saturn": [[181, 158, 123], [180, 160, 130], [140, 120, 100], [250, 240, 220], [86, 78, 68], [155, 149, 127]],
            "sunset_dream": [[255, 94, 77], [255, 142, 101], [255, 184, 128], [255, 215, 160], [180, 110, 90], [120, 60, 50]],
            "frosted_mint": [[200, 255, 230], [160, 240, 210], [120, 220, 190], [80, 200, 160], [40, 180, 130], [0, 150, 100]],
            "cosmic_violet": [[90, 50, 120], [120, 70, 150], [160, 100, 180], [200, 140, 210], [230, 190, 240], [50, 20, 80]],
            "desert_ember": [[210, 120, 80], [230, 150, 100], [245, 180, 120], [250, 210, 150], [180, 100, 70], [120, 60, 40]],
            "oceanic_tide": [[20, 60, 120], [30, 90, 160], [50, 120, 200], [80, 160, 220], [100, 180, 240], [10, 40, 100]],
            "forest_moss": [[50, 80, 40], [70, 110, 60], [100, 140, 90], [130, 170, 120], [160, 200, 150], [30, 60, 20]],
        };

        // --- Utility Functions ---
        const random = () => Math.random();
        const randint = (min, max) => Math.floor(random() * (max - min + 1)) + min;
        const uniform = (min, max) => random() * (max - min) + min;
        const choice = (arr) => arr[Math.floor(random() * arr.length)];
        const biased_randint = (low, high, bias = 2.0) => low + Math.floor(Math.pow(random(), bias) * (high - low + 1));
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        // --- Noise Functions ---
        let simplex; // will be initialized with a seed
        const seamless_horizontal_noise = (x, y, scale, stretch_factor = 4.0) => {
            const angle = 2 * Math.PI * x;
            const nx = Math.cos(angle) * scale / stretch_factor;
            const ny = Math.sin(angle) * scale / stretch_factor;
            const nz = y * scale;
            return simplex.noise3D(nx, ny, nz);
        };

        // --- Graphics & Math Helper Functions ---
        // A helper class to manage pixel data similar to a NumPy array
        class PixelArray {
            constructor(width, height, data = null) {
                this.width = width;
                this.height = height;
                this.data = data || new Float32Array(width * height * 4);
            }
            static fromImageData(imageData) {
                const floatData = new Float32Array(imageData.data);
                return new PixelArray(imageData.width, imageData.height, floatData);
            }
            toImageData() {
                const clampedData = new Uint8ClampedArray(this.data);
                return new ImageData(clampedData, this.width, this.height);
            }
            get(y, x) {
                const i = (y * this.width + x) * 4;
                return [this.data[i], this.data[i+1], this.data[i+2], this.data[i+3]];
            }
            set(y, x, color) {
                const i = (y * this.width + x) * 4;
                this.data[i] = color[0];
                this.data[i+1] = color[1];
                this.data[i+2] = color[2];
                if (color.length > 3) this.data[i+3] = color[3];
            }
            clone() {
                return new PixelArray(this.width, this.height, new Float32Array(this.data));
            }
        }

        // JS implementation of scipy's map_coordinates
        const mapCoordinates = (inputArray, coordinates) => {
            const outputArray = new PixelArray(inputArray.width, inputArray.height);
            const { width, height } = inputArray;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const newY = coordinates[0][y][x];
                    const newX = coordinates[1][y][x];

                    const x1 = Math.floor(newX);
                    const y1 = Math.floor(newY);
                    
                    // Bilinear interpolation
                    const dx = newX - x1;
                    const dy = newY - y1;

                    let finalColor = [0, 0, 0, 0];
                    for (let c = 0; c < 3; c++) {
                        const p1 = inputArray.get(y1, x1)[c];
                        const p2 = inputArray.get(y1, x1 + 1)[c];
                        const p3 = inputArray.get(y1 + 1, x1)[c];
                        const p4 = inputArray.get(y1 + 1, x1 + 1)[c];
                        
                        const val = p1 * (1 - dx) * (1 - dy) + p2 * dx * (1 - dy) + p3 * (1 - dx) * dy + p4 * dx * dy;
                        finalColor[c] = val;
                    }
                    outputArray.set(y, x, finalColor);
                }
            }
            return outputArray;
        };
        
        // JS implementation of skimage's swirl
        const swirl = (inputArray, centerY, centerX, strength, radius) => {
             const outputArray = inputArray.clone();
             const { width, height } = inputArray;
             for (let y = 0; y < height; y++) {
                 for (let x = 0; x < width; x++) {
                     const dx = x - centerX;
                     const dy = y - centerY;
                     const dist = Math.sqrt(dx * dx + dy * dy);
                     if (dist < radius) {
                         const factor = 1 - (dist / radius);
                         const angle = (strength * factor * factor) * Math.PI / 180;
                         const cosA = Math.cos(angle);
                         const sinA = Math.sin(angle);
                         const srcX = dx * cosA - dy * sinA + centerX;
                         const srcY = dx * sinA + dy * cosA + centerY;

                         if (srcX >= 0 && srcX < width - 1 && srcY >= 0 && srcY < height - 1) {
                             const x1 = Math.floor(srcX);
                             const y1 = Math.floor(srcY);
                             // Simplified to nearest neighbor for performance
                             outputArray.set(y, x, inputArray.get(y1, x1));
                         }
                     }
                 }
             }
             return outputArray;
        };
        
        const gaussianBlur = (inputArray, sigma) => {
            // Simplified horizontal blur for performance
            const outputArray = inputArray.clone();
            const { width, height } = inputArray;
            const radius = Math.floor(sigma * 3);
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    let total = 0;
                    let weightSum = 0;
                    for(let i = -radius; i <= radius; i++) {
                        const sampleX = Math.max(0, Math.min(width-1, x + i));
                        const weight = Math.exp(-(i*i) / (2*sigma*sigma));
                        total += inputArray.get(y, sampleX)[0] * weight;
                        weightSum += weight;
                    }
                    const val = total / weightSum;
                    outputArray.set(y, x, [val, val, val]);
                }
            }
            return outputArray;
        }


        // --- Core Generation Logic ---

        async function updateStatus(message) {
            statusText.textContent = message;
            await sleep(20); // Allow UI to update
        }

        async function addMainBands(planetArray, palette) {
            const { width, height } = planetArray;
            const num_bands = biased_randint(12, 20, 1.8);
            const band_colors = palette.slice(1);

            for (let i = 0; i < num_bands; i++) {
                await updateStatus(`Step 2: Drawing main cloud bands... (${i + 1}/${num_bands})`);
                const y_center = randint(0, height);
                const band_height = uniform(height * 0.05, height * 0.2);
                const band_color = choice(band_colors);
                const wave_amplitude = uniform(height * 0.01, height * 0.03);
                const wave_scale = uniform(3.0, 6.0);

                const bandLayer = new PixelArray(width, height);

                for (let x = 0; x < width; x++) {
                    const y_offset = seamless_horizontal_noise(x / width, i / num_bands, wave_scale) * wave_amplitude;
                    const waved_y_center = y_center + y_offset;

                    const turbulence_noise = (seamless_horizontal_noise(x / width, waved_y_center / height * 5, 30, 20.0) + 1) / 2;

                    for (let y = 0; y < height; y++) {
                        const intensity = 0.4 * Math.exp(-Math.pow(y - waved_y_center, 2) / (2 * Math.pow(band_height / 4, 2)));
                        const final_intensity = intensity * (0.6 + 0.4 * turbulence_noise);

                        const r = band_color[0] * final_intensity;
                        const g = band_color[1] * final_intensity;
                        const b = band_color[2] * final_intensity;
                        bandLayer.set(y, x, [r, g, b]);
                    }
                }
                
                // Blend
                for(let i=0; i < planetArray.data.length; i += 4) {
                    const band_r = bandLayer.data[i];
                    const alpha = Math.min(1, Math.max(band_r, bandLayer.data[i+1], bandLayer.data[i+2]) / 255.0);
                    planetArray.data[i] = planetArray.data[i] * (1-alpha) + band_r;
                    planetArray.data[i+1] = planetArray.data[i+1] * (1-alpha) + bandLayer.data[i+1];
                    planetArray.data[i+2] = planetArray.data[i+2] * (1-alpha) + bandLayer.data[i+2];
                }
            }
            return planetArray;
        }

        async function addGlowingJetStreams(planetArray) {
            const { width, height } = planetArray;
            const num_jets = randint(3, 8);
            
            for (let i = 0; i < num_jets; i++) {
                await updateStatus(`Step 3: Adding glowing jet streams... (${i + 1}/${num_jets})`);
                const jetLayer = new PixelArray(width, height);
                const y_center = randint(0, height);
                const jet_height = uniform(height * 0.005, height * 0.015);
                const glow_color = [240, 240, 255];
                
                const main_wave_amp = uniform(height * 0.02, height * 0.04);
                const main_wave_scale = uniform(4.0, 8.0);
                const turb_wave_amp = uniform(height * 0.005, height * 0.01);
                const turb_wave_scale = uniform(2.0, 4.0);

                for (let x = 0; x < width; x++) {
                    const x_norm = x / width;
                    const main_offset = seamless_horizontal_noise(x_norm, i / num_jets, main_wave_scale) * main_wave_amp;
                    const turb_offset = seamless_horizontal_noise(x_norm, i / num_jets, turb_wave_scale, 2.0) * turb_wave_amp;
                    const waved_y_center = y_center + main_offset + turb_offset;
                    
                    const mask = (simplex.noise2D(x_norm * (width / 60.0), i * 5) + 1) / 2;
                    let alpha = Math.pow(mask, 1.5);
                    if (random() < 0.002) alpha *= uniform(0.0, 0.3);

                    for (let y = 0; y < height; y++) {
                        const intensity = Math.exp(-Math.pow(y - waved_y_center, 2) / (2 * Math.pow(jet_height / 2, 2)));
                        const r = glow_color[0] * intensity * alpha;
                        const g = glow_color[1] * intensity * alpha;
                        const b = glow_color[2] * intensity * alpha;
                        jetLayer.set(y, x, [r, g, b]);
                    }
                }
                
                const blend_strength = uniform(0.1, 0.3);
                for(let i=0; i < planetArray.data.length; i += 4) {
                    planetArray.data[i] += jetLayer.data[i] * blend_strength;
                    planetArray.data[i+1] += jetLayer.data[i+1] * blend_strength;
                    planetArray.data[i+2] += jetLayer.data[i+2] * blend_strength;
                }
            }
            return planetArray;
        }

        async function applyFlowDistortion(planetArray) {
            const { width, height } = planetArray;
            const strength = uniform(5, 15);
            
            const coordsY = Array(height).fill(0).map(() => Array(width));
            const coordsX = Array(height).fill(0).map(() => Array(width));

            for (let y = 0; y < height; y++) {
                if (y % 10 === 0) await updateStatus(`Step 4: Generating flow map... (${Math.round(y/height * 100)}%)`);
                for (let x = 0; x < width; x++) {
                    const x_norm = x / width;
                    const y_norm = y / height;
                    const y_offset = seamless_horizontal_noise(x_norm, y_norm, 8.0, 1.0);
                    const x_offset = seamless_horizontal_noise(x_norm, y_norm, 5.0, 5.0);
                    
                    coordsY[y][x] = y + y_offset * strength;
                    coordsX[y][x] = x + x_offset * (strength / 4);
                    // Wrap X
                    coordsX[y][x] = (coordsX[y][x] + width) % width;
                }
            }
            
            await updateStatus(`Step 4: Applying distortion...`);
            // This is a slow operation in JS
            return mapCoordinates(planetArray, [coordsY, coordsX]);
        }

        async function addGreatStorm(planetArray, palette) {
             const { width, height } = planetArray;
             const cy = randint(height * 0.2, height * 0.8);
             const cx = randint(width * 0.2, width * 0.8);
             const radius_y = uniform(height * 0.08, height * 0.15);
             const radius_x = radius_y * uniform(1.5, 2.5);
             const storm_color = choice([PALETTES["sunset_dream"][1], PALETTES["cosmic_violet"][5]]);
             
             // Create flow-around effect
             await updateStatus(`Step 5: Creating storm flow-around effect...`);
             const distorted_base_array = planetArray.clone(); // Simplified for now
             
             // Create storm texture
             await updateStatus(`Step 5: Generating storm texture...`);
             const stormTextureLayer = new PixelArray(width, height);
             const maskArray = new PixelArray(width, height);

             for (let y = 0; y < height; y++) {
                 for (let x = 0; x < width; x++) {
                     const dist_sq = Math.pow((x - cx) / radius_x, 2) + Math.pow((y - cy) / radius_y, 2);
                     if (dist_sq < 1.2) { // Process a slightly larger area for blurring
                         const edge_noise = simplex.noise2D(x / 25.0, y / 25.0);
                         if (dist_sq / (1.0 + 0.3 * edge_noise) < 1.0) {
                              maskArray.set(y, x, [1,1,1]);
                         }
                         const internal_noise = (simplex.noise2D(x / 50.0, y / 50.0) + 1) / 2;
                         const r = storm_color[0] * internal_noise;
                         const g = storm_color[1] * internal_noise;
                         const b = storm_color[2] * internal_noise;
                         stormTextureLayer.set(y, x, [r,g,b]);
                     }
                 }
             }

             await updateStatus(`Step 5: Blurring storm mask...`);
             const blurredMask = gaussianBlur(maskArray, 8);
             
             await updateStatus(`Step 5: Swirling storm...`);
             const swirled_storm = swirl(stormTextureLayer, cy, cx, uniform(5, 8), Math.max(radius_x, radius_y) * 1.5);
             
             // Blend
             for(let i=0; i < planetArray.data.length; i+=4) {
                 const mask = blurredMask.data[i];
                 planetArray.data[i] = planetArray.data[i] * (1-mask) + swirled_storm.data[i] * mask;
                 planetArray.data[i+1] = planetArray.data[i+1] * (1-mask) + swirled_storm.data[i+1] * mask;
                 planetArray.data[i+2] = planetArray.data[i+2] * (1-mask) + swirled_storm.data[i+2] * mask;
             }
             return planetArray;
        }

        async function addSeamlessStorms(planetArray) {
            const { width, height } = planetArray;
            const num_storms = randint(2, 4);

            let tempArray = planetArray;
            for (let i = 0; i < num_storms; i++) {
                await updateStatus(`Step 6: Adding seamless eddies... (${i + 1}/${num_storms})`);
                const cx = randint(width * 0.25, width * 0.75);
                const cy = randint(0, height - 1);
                const radius = randint(width * 0.08, width * 0.15);
                const strength = uniform(1.5, 3.0) * choice([-1, 1]);
                tempArray = swirl(tempArray, cy, cx, strength, radius);
            }
            return tempArray;
        }


        // --- Main Execution ---
        async function generate() {
            // --- UI Setup ---
            generateBtn.disabled = true;
            spinner.classList.remove('hidden');
            btnText.textContent = "正在生成...";
            downloadLink.classList.add('hidden');

            // --- Get Settings ---
            const resolution = resolutionSelect.value;
            const paletteKey = paletteSelect.value;
            const doGreatStorm = greatStormCheckbox.checked;

            const WIDTH = resolution === '1k' ? 1024 : 2048;
            const HEIGHT = resolution === '1k' ? 512 : 1024;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;

            const seed = Date.now();
            simplex = new SimplexNoise(seed);

            const paletteName = paletteKey === 'random' ? choice(Object.keys(PALETTES)) : paletteKey;
            const palette = PALETTES[paletteName];

            // --- Generation Steps ---
            await updateStatus("Step 1: Generating base color...");
            const base_color = palette[0];
            ctx.fillStyle = `rgb(${base_color[0]}, ${base_color[1]}, ${base_color[2]})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            let planetArray = PixelArray.fromImageData(ctx.getImageData(0, 0, WIDTH, HEIGHT));

            planetArray = await addMainBands(planetArray, palette);
            planetArray = await addGlowingJetStreams(planetArray);
            planetArray = await applyFlowDistortion(planetArray);
            if (doGreatStorm) {
                planetArray = await addGreatStorm(planetArray, palette);
            }
            planetArray = await addSeamlessStorms(planetArray);
            
            await updateStatus("Finalizing image...");

            // Clip values
            for(let i=0; i<planetArray.data.length; i++) {
                planetArray.data[i] = Math.max(0, Math.min(255, planetArray.data[i]));
            }
            
            ctx.putImageData(planetArray.toImageData(), 0, 0);

            // --- UI Teardown ---
            statusText.textContent = `完成! (调色板: ${paletteName})`;
            downloadLink.href = canvas.toDataURL('image/png');
            downloadLink.download = `gas_giant_${paletteName}_${seed}.png`;
            downloadLink.classList.remove('hidden');
            generateBtn.disabled = false;
            spinner.classList.add('hidden');
            btnText.textContent = "生成贴图";
        }

        // --- Initialization ---
        function init() {
            // Populate palette select
            Object.keys(PALETTES).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                paletteSelect.appendChild(option);
            });

            generateBtn.addEventListener('click', generate);

            // Generate on load
            generate();
        }

        init();
    </script>
</body>
</html>
