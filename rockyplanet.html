<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Planet Generator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
        }
        .container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls {
            background-color: #2b2b2b;
            padding: 25px;
            border-radius: 8px;
            width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .output {
            text-align: center;
        }
        h1, h2 {
            color: #ffffff;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ccc;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        input[type="number"], input[type="text"] {
            width: 80px;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-family: monospace;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.download-btn {
            background-color: #28a745;
            margin-top: 10px;
        }
        button.download-btn:hover {
            background-color: #1e7e34;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #planetCanvas {
            background-color: #000;
            border: 2px solid #444;
            border-radius: 4px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-width: 100%;
        }
        #status {
            margin-top: 15px;
            font-style: italic;
            color: #aaa;
            height: 20px;
        }
        .seed-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .seed-group input {
            flex-grow: 1;
        }
        .seed-group button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h1>Controls</h1>
        
        <div class="control-group">
            <label for="size">Resolution</label>
            <input type="radio" id="size1k" name="size" value="1024" checked>
            <label for="size1k" style="display: inline; margin-right: 15px;">1K (1024x512)</label>
            <input type="radio" id="size2k" name="size" value="2048">
            <label for="size2k" style="display: inline;">2K (2048x1024)</label>
        </div>

        <div class="control-group">
            <label for="seaLevel">Sea Level: <span class="value-display" id="seaLevelValue">0.50</span></label>
            <input type="range" id="seaLevel" min="0" max="1" step="0.01" value="0.5">
        </div>

        <div class="control-group">
            <label for="desertification">Desertification: <span class="value-display" id="desertificationValue">1.50</span></label>
            <input type="range" id="desertification" min="0.5" max="5" step="0.01" value="1.5">
        </div>

        <div class="control-group">
            <label for="iceCapLatitude">Ice Cap Latitude: <span class="value-display" id="iceCapLatitudeValue">0.80</span></label>
            <input type="range" id="iceCapLatitude" min="0.5" max="1" step="0.01" value="0.8">
        </div>
        
        <div class="control-group">
            <label for="seed">Seed</label>
            <div class="seed-group">
                <input type="text" id="seed" value="42">
                <button id="randomSeedBtn">Random</button>
            </div>
        </div>

        <button id="generateBtn">Generate Planet</button>
        <div id="status"></div>

        <button id="downloadColorBtn" class="download-btn" disabled>Download Color Map</button>
        <button id="downloadHeightBtn" class="download-btn" disabled>Download Height Map</button>
    </div>

    <div class="output">
        <h2>Generated Planet Texture</h2>
        <canvas id="planetCanvas" width="1024" height="512"></canvas>
    </div>
</div>

<script>
// --- Simplex Noise JS Library (by Jonas Wagner) - CORRECTED VERSION ---
// This version is clean and does not use reserved keywords as variables.
const SimplexNoise = (function() {
    const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
    const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
    const F3 = 1.0 / 3.0;
    const G3 = 1.0 / 6.0;
    const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
    const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

    function SimplexNoise(randomOrSeed) {
        if (typeof randomOrSeed == 'function') {
            this.random = randomOrSeed;
        } else if (randomOrSeed) {
            this.random = alea(randomOrSeed);
        } else {
            this.random = Math.random;
        }
        this.p = new Uint8Array(256);
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (let i = 0; i < 256; i++) {
            this.p[i] = i;
        }
        for (let i = 255; i > 0; i--) {
            const r = Math.floor(this.random() * (i + 1));
            const t = this.p[i];
            this.p[i] = this.p[r];
            this.p[r] = t;
        }
        for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
            this.permMod12[i] = this.perm[i] % 12;
        }
    }

    SimplexNoise.prototype = {
        grad3: new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]),
        noise2D: function(xin, yin) {
            let n0, n1, n2;
            let s = (xin + yin) * F2;
            let i = Math.floor(xin + s);
            let j = Math.floor(yin + s);
            let t = (i + j) * G2;
            let X0 = i - t;
            let Y0 = j - t;
            let x0 = xin - X0;
            let y0 = yin - Y0;
            let i1, j1;
            if (x0 > y0) {
                i1 = 1;
                j1 = 0;
            } else {
                i1 = 0;
                j1 = 1;
            }
            let x1 = x0 - i1 + G2;
            let y1 = y0 - j1 + G2;
            let x2 = x0 - 1.0 + 2.0 * G2;
            let y2 = y0 - 1.0 + 2.0 * G2;
            let ii = i & 255;
            let jj = j & 255;
            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 < 0) n0 = 0.0;
            else {
                t0 *= t0;
                let gi0 = this.permMod12[ii + this.perm[jj]] * 3;
                n0 = t0 * t0 * (this.grad3[gi0] * x0 + this.grad3[gi0 + 1] * y0);
            }
            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 < 0) n1 = 0.0;
            else {
                t1 *= t1;
                let gi1 = this.permMod12[ii + i1 + this.perm[jj + j1]] * 3;
                n1 = t1 * t1 * (this.grad3[gi1] * x1 + this.grad3[gi1 + 1] * y1);
            }
            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 < 0) n2 = 0.0;
            else {
                t2 *= t2;
                let gi2 = this.permMod12[ii + 1 + this.perm[jj + 1]] * 3;
                n2 = t2 * t2 * (this.grad3[gi2] * x2 + this.grad3[gi2 + 1] * y2);
            }
            return 70.0 * (n0 + n1 + n2);
        },
        noise3D: function(xin, yin, zin) {
            let n0, n1, n2, n3;
            let s = (xin + yin + zin) * F3;
            let i = Math.floor(xin + s);
            let j = Math.floor(yin + s);
            let k = Math.floor(zin + s);
            let t = (i + j + k) * G3;
            let X0 = i - t;
            let Y0 = j - t;
            let Z0 = k - t;
            let x0 = xin - X0;
            let y0 = yin - Y0;
            let z0 = zin - Z0;
            let i1, j1, k1, i2, j2, k2;
            if (x0 >= y0) {
                if (y0 >= z0) {
                    i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                } else if (x0 >= z0) {
                    i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;
                } else {
                    i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;
                }
            } else {
                if (y0 < z0) {
                    i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;
                } else if (x0 < z0) {
                    i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;
                } else {
                    i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;
                }
            }
            let x1 = x0 - i1 + G3;
            let y1 = y0 - j1 + G3;
            let z1 = z0 - k1 + G3;
            let x2 = x0 - i2 + 2.0 * G3;
            let y2 = y0 - j2 + 2.0 * G3;
            let z2 = z0 - k2 + 2.0 * G3;
            let x3 = x0 - 1.0 + 3.0 * G3;
            let y3 = y0 - 1.0 + 3.0 * G3;
            let z3 = z0 - 1.0 + 3.0 * G3;
            let ii = i & 255;
            let jj = j & 255;
            let kk = k & 255;
            let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0) n0 = 0.0;
            else {
                t0 *= t0;
                let gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]] * 3;
                n0 = t0 * t0 * (this.grad3[gi0] * x0 + this.grad3[gi0 + 1] * y0 + this.grad3[gi0 + 2] * z0);
            }
            let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0) n1 = 0.0;
            else {
                t1 *= t1;
                let gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] * 3;
                n1 = t1 * t1 * (this.grad3[gi1] * x1 + this.grad3[gi1 + 1] * y1 + this.grad3[gi1 + 2] * z1);
            }
            let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0) n2 = 0.0;
            else {
                t2 *= t2;
                let gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] * 3;
                n2 = t2 * t2 * (this.grad3[gi2] * x2 + this.grad3[gi2 + 1] * y2 + this.grad3[gi2 + 2] * z2);
            }
            let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0) n3 = 0.0;
            else {
                t3 *= t3;
                let gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] * 3;
                n3 = t3 * t3 * (this.grad3[gi3] * x3 + this.grad3[gi3 + 1] * y3 + this.grad3[gi3 + 2] * z3);
            }
            return 32.0 * (n0 + n1 + n2 + n3);
        }
    };

    function alea(seed) {
        let s0 = 0;
        let s1 = 0;
        let s2 = 0;
        let c = 1;
        if (seed == null) {
            seed = +new Date;
        }
        s0 = (seed >>> 0) * 0x9e3779b9;
        s1 = seed * 0x9e3779b9;
        s2 = seed * 0x9e3779b9;

        for (let i = 0; i < 20; i++) {
            s0 = (s0 + s1 + c) * 0x9e3779b9;
            s1 = (s1 + s2 + c) * 0x9e3779b9;
            s2 = (s2 + s0 + c) * 0x9e3779b9;
        }
        return function() {
            let t = (s0 + s1 + c) * 0x9e3779b9;
            s0 = (s1 ^ s1 >>> 9) * 0x9e3779b9;
            s1 = (s2 + (s2 << 3)) * 0x9e3779b9;
            s2 = (s2 << 21 | s2 >>> 11);
            c = t >>> 0;
            return (t - Math.floor(t)) * 1;
        };
    }
    return SimplexNoise;
})();

let simplex; // Will be initialized with seed later

// DOM Elements
const controls = {
    size: () => document.querySelector('input[name="size"]:checked').value,
    seaLevel: document.getElementById('seaLevel'),
    desertification: document.getElementById('desertification'),
    iceCapLatitude: document.getElementById('iceCapLatitude'),
    seed: document.getElementById('seed'),
    generateBtn: document.getElementById('generateBtn'),
    randomSeedBtn: document.getElementById('randomSeedBtn'),
    downloadColorBtn: document.getElementById('downloadColorBtn'),
    downloadHeightBtn: document.getElementById('downloadHeightBtn'),
};

const displays = {
    seaLevelValue: document.getElementById('seaLevelValue'),
    desertificationValue: document.getElementById('desertificationValue'),
    iceCapLatitudeValue: document.getElementById('iceCapLatitudeValue'),
    status: document.getElementById('status'),
};

const canvas = document.getElementById('planetCanvas');
const ctx = canvas.getContext('2d');

let heightMapData, colorMapData, currentSeed;

// --- Main Generator Logic (Translated from Python) ---

const mapToSphere = (x, y, width, height) => {
    const lon_deg = (x / width) * 360.0;
    const lat_deg = (y / height) * 180.0 - 90.0;
    
    const lon_rad = (lon_deg * Math.PI) / 180.0;
    const lat_rad = (lat_deg * Math.PI) / 180.0;
    
    const sphere_x = Math.cos(lat_rad) * Math.cos(lon_rad);
    const sphere_y = Math.cos(lat_rad) * Math.sin(lon_rad);
    const sphere_z = Math.sin(lat_rad);
    
    return { x: sphere_x, y: sphere_y, z: sphere_z };
};

const generateTerrainMaps = (width, height, seed) => {
    const heightMap = new Float32Array(width * height);
    const moistureMap = new Float32Array(width * height);

    displays.status.textContent = "Generating terrain data...";

    const SCALE = 200.0;
    const OCTAVES = 8;
    const PERSISTENCE = 0.5;
    const LACUNARITY = 2.0;
    const moisture_scale = SCALE * 1.5;
    const moisture_octaves = 4;

    const angle_rad = simplex.random() * 2 * Math.PI;
    const cos_a = Math.cos(angle_rad);
    const sin_a = Math.sin(angle_rad);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const sphereCoords = mapToSphere(x, y, width, height);
            
            const rotated_sx = sphereCoords.x * cos_a - sphereCoords.y * sin_a;
            const rotated_sy = sphereCoords.x * sin_a + sphereCoords.y * cos_a;
            const rotated_sz = sphereCoords.z;

            let height_val = 0;
            let m_val = 0;
            let freq = 1.0;
            let amp = 1.0;
            let maxAmp = 0;

            for(let i = 0; i < OCTAVES; i++) {
                height_val += simplex.noise3D(
                    rotated_sx * freq * SCALE / 100, 
                    rotated_sy * freq * SCALE / 100, 
                    rotated_sz * freq * SCALE / 100 + seed
                ) * amp;
                if(i < moisture_octaves) {
                    m_val += simplex.noise3D(
                        rotated_sy * freq * moisture_scale / 100 + seed + 500,
                        rotated_sz * freq * moisture_scale / 100 + seed + 500,
                        rotated_sx * freq * moisture_scale / 100 + seed + 500
                    ) * amp;
                }
                maxAmp += amp;
                freq *= LACUNARITY;
                amp *= PERSISTENCE;
            }
            const index = y * width + x;
            heightMap[index] = height_val / maxAmp;
            moistureMap[index] = m_val / maxAmp;
        }
    }
    
    // Normalize maps
    const normalize = (map) => {
        let min = Infinity, max = -Infinity;
        for(let i = 0; i < map.length; i++) {
            if(map[i] < min) min = map[i];
            if(map[i] > max) max = map[i];
        }
        const range = max - min;
        if (range === 0) return map;
        for(let i = 0; i < map.length; i++) {
            map[i] = (map[i] - min) / range;
        }
        return map;
    };
    
    normalize(heightMap);
    normalize(moistureMap);

    for(let i = 0; i < heightMap.length; i++) {
        heightMap[i] = Math.pow(heightMap[i], 1.5);
    }
    
    return { heightMap, moistureMap };
};


const generateColorMap = (width, height, params, terrainMaps) => {
    const { heightMap, moistureMap } = terrainMaps;
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;

    displays.status.textContent = "Simulating climate and drawing map...";

    const COLOR_DEEP_WATER = [10, 15, 60];
    const COLOR_SHALLOW_WATER = [15, 20, 65];
    const COLOR_SAND = [210, 190, 140];
    const COLOR_GRASS = [80, 140, 70];
    const COLOR_ROCK = [130, 120, 110];
    const COLOR_SNOW = [245, 245, 255];
    const COLOR_ICE = [230, 235, 255];

    const MOUNTAIN_PEAK = Math.min(params.SEA_LEVEL + 0.35, 0.95);
    const SNOW_LINE = Math.max(MOUNTAIN_PEAK - 0.15, params.SEA_LEVEL);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = y * width + x;
            const h = heightMap[index];
            const m = moistureMap[index];

            // --- Step 1: Calculate base terrain color ---
            const latitude_factor = 1.0 - Math.abs(y - height / 2) / (height / 2);
            let temp = latitude_factor * 0.8 + 0.1;
            if (h > params.SEA_LEVEL) temp -= (h - params.SEA_LEVEL) * 0.5;

            let terrain_color = [0, 0, 0];
            if (h < params.SEA_LEVEL) {
                const depth_factor = params.SEA_LEVEL > 0 ? h / params.SEA_LEVEL : 0;
                for (let i = 0; i < 3; i++) terrain_color[i] = (1 - depth_factor) * COLOR_DEEP_WATER[i] + depth_factor * COLOR_SHALLOW_WATER[i];
            } else if (temp < 0.15 || h > SNOW_LINE + (1 - temp) * 0.2) {
                terrain_color = COLOR_SNOW;
            } else if (h > MOUNTAIN_PEAK) {
                terrain_color = COLOR_ROCK;
            } else if (h > params.SEA_LEVEL + 0.02) {
                const desert_threshold = params.DESERTIFICATION * 0.7;
                if (m < desert_threshold && temp > 0.4) {
                    terrain_color = COLOR_SAND;
                } else {
                    const rock_factor = (h - (params.SEA_LEVEL + 0.02)) / (MOUNTAIN_PEAK - (params.SEA_LEVEL + 0.02));
                    for (let i = 0; i < 3; i++) terrain_color[i] = (1 - rock_factor) * COLOR_GRASS[i] + rock_factor * COLOR_ROCK[i];
                }
            } else {
                terrain_color = COLOR_SAND;
            }
            
            // --- Step 2: Overlay Ice Caps ---
            const abs_latitude_factor = Math.abs(y - height / 2) / (height / 2);
            const ice_cap_edge_noise = (m - 0.5) * 0.1;
            let ice_factor = 0.0;
            if (abs_latitude_factor > params.ICE_CAP_LATITUDE - ice_cap_edge_noise) {
                const blend_range = 0.1;
                ice_factor = (abs_latitude_factor - (params.ICE_CAP_LATITUDE - ice_cap_edge_noise)) / blend_range;
                ice_factor = Math.max(0, Math.min(1, ice_factor));
            }
            
            let final_color = [0, 0, 0];
            for (let i = 0; i < 3; i++) final_color[i] = (1 - ice_factor) * terrain_color[i] + ice_factor * COLOR_ICE[i];

            // --- Step 3: Add central artifact correction noise (land only) ---
            if (h >= params.SEA_LEVEL) {
                const center_x = width / 2;
                const distance_from_center = Math.abs(x - center_x);
                let center_blend_factor = 0.0;
                
                if (distance_from_center < params.CENTER_NOISE_WIDTH) {
                    center_blend_factor = 1.0 - (distance_from_center / params.CENTER_NOISE_WIDTH);
                }
                
                if (center_blend_factor > 0) {
                    const sphereCoords = mapToSphere(x, y, width, height);
                    let noise_val = 0;
                    let freq = 1.0, amp = 1.0, maxAmp = 0;
                     for(let i = 0; i < 4; i++) {
                        noise_val += simplex.noise3D(
                            sphereCoords.x * freq * params.CENTER_NOISE_SCALE,
                            sphereCoords.y * freq * params.CENTER_NOISE_SCALE,
                            sphereCoords.z * freq * params.CENTER_NOISE_SCALE + params.SEED + 1000
                        ) * amp;
                        maxAmp += amp;
                        freq *= 2.0;
                        amp *= 0.5;
                    }

                    noise_val = (noise_val / maxAmp + 1.0) / 2.0; // Normalize to 0-1
                    const noise_offset = (noise_val - 0.5) * 2 * params.CENTER_NOISE_STRENGTH * 255;
                    for (let i = 0; i < 3; i++) final_color[i] += noise_offset * center_blend_factor;
                }
            }
            
            const pixelIndex = (y * width + x) * 4;
            data[pixelIndex] = Math.max(0, Math.min(255, final_color[0]));
            data[pixelIndex + 1] = Math.max(0, Math.min(255, final_color[1]));
            data[pixelIndex + 2] = Math.max(0, Math.min(255, final_color[2]));
            data[pixelIndex + 3] = 255;
        }
    }
    return imageData;
};

// --- UI and Event Handling ---

function updateSliderValue(slider, display) {
    display.textContent = parseFloat(slider.value).toFixed(2);
}

function attachSliderEvents() {
    controls.seaLevel.addEventListener('input', () => updateSliderValue(controls.seaLevel, displays.seaLevelValue));
    controls.desertification.addEventListener('input', () => updateSliderValue(controls.desertification, displays.desertificationValue));
    controls.iceCapLatitude.addEventListener('input', () => updateSliderValue(controls.iceCapLatitude, displays.iceCapLatitudeValue));
}

function downloadCanvas(filename, canvasToDownload) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvasToDownload.toDataURL("image/png").replace("image/png", "image/octet-stream");
    link.click();
}

function drawHeightMap(width, height, heightMap) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(width, height);
    const data = imageData.data;

    for(let i=0; i < heightMap.length; i++) {
        const val = Math.floor(heightMap[i] * 255);
        const pixelIndex = i * 4;
        data[pixelIndex] = val;
        data[pixelIndex+1] = val;
        data[pixelIndex+2] = val;
        data[pixelIndex+3] = 255;
    }
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

function main() {
    controls.generateBtn.disabled = true;
    controls.downloadColorBtn.disabled = true;
    controls.downloadHeightBtn.disabled = true;

    const width = parseInt(controls.size(), 10);
    const height = width / 2;

    canvas.width = width;
    canvas.height = height;
    
    currentSeed = parseInt(controls.seed.value, 10) || Math.floor(Math.random() * 99999);
    controls.seed.value = currentSeed;
    
    // Initialize simplex noise with the current seed for reproducibility
    simplex = new SimplexNoise(currentSeed.toString());

    const params = {
        WIDTH: width,
        HEIGHT: height,
        SEED: currentSeed,
        SEA_LEVEL: parseFloat(controls.seaLevel.value),
        DESERTIFICATION: parseFloat(controls.desertification.value),
        ICE_CAP_LATITUDE: parseFloat(controls.iceCapLatitude.value),
        CENTER_NOISE_WIDTH: parseFloat(document.querySelector('input[name=size]:checked').dataset.centerWidth),
        CENTER_NOISE_STRENGTH: 0.3,
        CENTER_NOISE_SCALE: 30.0
    };

    // Use a timeout to allow the UI to update with the status message
    setTimeout(() => {
        const terrainMaps = generateTerrainMaps(width, height, params.SEED);
        heightMapData = terrainMaps.heightMap; // Store for download

        const colorMapImageData = generateColorMap(width, height, params, terrainMaps);
        ctx.putImageData(colorMapImageData, 0, 0);

        displays.status.textContent = `Done! (Seed: ${params.SEED})`;
        controls.generateBtn.disabled = false;
        controls.downloadColorBtn.disabled = false;
        controls.downloadHeightBtn.disabled = false;
    }, 10);
}

// Initial setup
document.addEventListener('DOMContentLoaded', () => {
    attachSliderEvents();
    
    // Set data attributes for center noise width based on resolution
    document.getElementById('size1k').dataset.centerWidth = "20";
    document.getElementById('size2k').dataset.centerWidth = "40";

    controls.randomSeedBtn.addEventListener('click', () => {
        controls.seed.value = Math.floor(Math.random() * 99999);
    });

    controls.generateBtn.addEventListener('click', main);

    controls.downloadColorBtn.addEventListener('click', () => {
        downloadCanvas(`planet_colormap_${currentSeed}.png`, canvas);
    });

    controls.downloadHeightBtn.addEventListener('click', () => {
        if(heightMapData) {
            displays.status.textContent = "Preparing heightmap for download...";
            setTimeout(() => {
                const heightMapCanvas = drawHeightMap(canvas.width, canvas.height, heightMapData);
                downloadCanvas(`planet_heightmap_${currentSeed}.png`, heightMapCanvas);
                displays.status.textContent = `Done! (Seed: ${currentSeed})`;
            }, 10);
        }
    });
    
    // Initial random seed and generation
    controls.randomSeedBtn.click();
    main();
});

</script>
</body>
</html>
