<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Planet Generator</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
        }
        .container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .controls {
            background-color: #2b2b2b;
            padding: 25px;
            border-radius: 8px;
            width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .output {
            text-align: center;
        }
        h1, h2 {
            color: #ffffff;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-top: 0;
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #ccc;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        input[type="number"], input[type="text"] {
            width: 80px;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-family: monospace;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.download-btn {
            background-color: #28a745;
            margin-top: 10px;
        }
        button.download-btn:hover {
            background-color: #1e7e34;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #planetCanvas {
            background-color: #000;
            border: 2px solid #444;
            border-radius: 4px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-width: 100%;
        }
        #status {
            margin-top: 15px;
            font-style: italic;
            color: #aaa;
            height: 20px;
        }
        .seed-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .seed-group input {
            flex-grow: 1;
        }
        .seed-group button {
            width: auto;
            padding: 5px 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <h1>Controls</h1>
        
        <div class="control-group">
            <label for="size">Resolution</label>
            <input type="radio" id="size1k" name="size" value="1024" checked>
            <label for="size1k" style="display: inline; margin-right: 15px;">1K (1024x512)</label>
            <input type="radio" id="size2k" name="size" value="2048">
            <label for="size2k" style="display: inline;">2K (2048x1024)</label>
        </div>

        <div class="control-group">
            <label for="seaLevel">Sea Level: <span class="value-display" id="seaLevelValue">0.50</span></label>
            <input type="range" id="seaLevel" min="0" max="1" step="0.01" value="0.5">
        </div>

        <div class="control-group">
            <label for="desertification">Desertification: <span class="value-display" id="desertificationValue">1.50</span></label>
            <input type="range" id="desertification" min="0.5" max="10" step="0.01" value="1.5">
        </div>

        <div class="control-group">
            <label for="iceCapLatitude">Ice Cap Latitude: <span class="value-display" id="iceCapLatitudeValue">0.80</span></label>
            <input type="range" id="iceCapLatitude" min="0.5" max="1.2" step="0.01" value="0.8">
        </div>
        
        <div class="control-group">
            <label for="seed">Seed</label>
            <div class="seed-group">
                <input type="text" id="seed" value="42">
                <button id="randomSeedBtn">Random</button>
            </div>
        </div>

        <button id="generateBtn" disabled>Generate Planet</button>
        <div id="status"></div>

        <button id="downloadColorBtn" class="download-btn" disabled>Download Color Map</button>
        <button id="downloadHeightBtn" class="download-btn" disabled>Download Height Map</button>
    </div>

    <div class="output">
        <h2>Generated Planet Texture</h2>
        <canvas id="planetCanvas" width="1024" height="512"></canvas>
    </div>
</div>

<script>
// --- Simplex Noise JS Library (by Jonas Wagner) ---
const SimplexNoise = (function() { /* ... SNIPPED FOR BREVITY, full library code is here ... */ const F2=0.5*(Math.sqrt(3)-1),G2=(3-Math.sqrt(3))/6,F3=1/3,G3=1/6,F4=(Math.sqrt(5)-1)/4,G4=(5-Math.sqrt(5))/20;function SimplexNoise(randomOrSeed){"function"==typeof randomOrSeed?this.random=randomOrSeed:randomOrSeed?this.random=alea(randomOrSeed):this.random=Math.random,this.p=new Uint8Array(256),this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(let i=0;i<256;i++)this.p[i]=i;for(let i=255;i>0;i--){const r=Math.floor(this.random()*(i+1)),t=this.p[i];this.p[i]=this.p[r],this.p[r]=t}for(let i=0;i<512;i++)this.perm[i]=this.p[255&i],this.permMod12[i]=this.perm[i]%12}function alea(seed){let s0=0,s1=0,s2=0,c=1;null==seed&&(seed=+new Date),s0=4294967296*(seed>>>0),s1=4294967296*seed,s2=4294967296*seed;for(let i=0;i<20;i++)s0=(s0+s1+c)*.4294967296,s1=(s1+s2+c)*.4294967296,s2=(s2+s0+c)*.4294967296;return function(){let t=(s0+s1+c)*.4294967296;return s0=(s1^s1>>>9)*.4294967296,s1=(s2+(s2<<3))*.4294967296,s2=s2<<21|s2>>>11,c=t>>>0,(t-Math.floor(t))*1}}return SimplexNoise.prototype={grad3:new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),noise2D:function(xin,yin){let n0,n1,n2,s=(xin+yin)*F2,i=Math.floor(xin+s),j=Math.floor(yin+s),t=(i+j)*G2,X0=i-t,Y0=j-t,x0=xin-X0,y0=yin-Y0,i1,j1;x0>y0?(i1=1,j1=0):(i1=0,j1=1);let x1=x0-i1+G2,y1=y0-j1+G2,x2=x0-1+2*G2,y2=y0-1+2*G2,ii=255&i,jj=255&j,t0=.5-x0*x0-y0*y0;if(t0<0)n0=0;else{t0*=t0;let gi0=3*this.permMod12[ii+this.perm[jj]];n0=t0*t0*(this.grad3[gi0]*x0+this.grad3[gi0+1]*y0)}let t1=.5-x1*x1-y1*y1;if(t1<0)n1=0;else{t1*=t1;let gi1=3*this.permMod12[ii+i1+this.perm[jj+j1]];n1=t1*t1*(this.grad3[gi1]*x1+this.grad3[gi1+1]*y1)}let t2=.5-x2*x2-y2*y2;if(t2<0)n2=0;else{t2*=t2;let gi2=3*this.permMod12[ii+1+this.perm[jj+1]];n2=t2*t2*(this.grad3[gi2]*x2+this.grad3[gi2+1]*y2)}return 70*(n0+n1+n2)},noise3D:function(xin,yin,zin){let n0,n1,n2,n3,s=(xin+yin+zin)*F3,i=Math.floor(xin+s),j=Math.floor(yin+s),k=Math.floor(zin+s),t=(i+j+k)*G3,X0=i-t,Y0=j-t,Z0=k-t,x0=xin-X0,y0=yin-Y0,z0=zin-Z0,i1,j1,k1,i2,j2,k2;x0>=y0?y0>=z0?(i1=1,j1=0,k1=0,i2=1,j2=1,k2=0):x0>=z0?(i1=1,j1=0,k1=0,i2=1,j2=0,k2=1):(i1=0,j1=0,k1=1,i2=1,j2=0,k2=1):y0<z0?(i1=0,j1=0,k1=1,i2=0,j2=1,k2=1):x0<z0?(i1=0,j1=1,k1=0,i2=0,j2=1,k2=1):(i1=0,j1=1,k1=0,i2=1,j2=1,k2=0);let x1=x0-i1+G3,y1=y0-j1+G3,z1=z0-k1+G3,x2=x0-i2+2*G3,y2=y0-j2+2*G3,z2=z0-k2+2*G3,x3=x0-1+3*G3,y3=y0-1+3*G3,z3=z0-1+3*G3,ii=255&i,jj=255&j,kk=255&k,t0=.6-x0*x0-y0*y0-z0*z0;if(t0<0)n0=0;else{t0*=t0;let gi0=3*this.permMod12[ii+this.perm[jj+this.perm[kk]]];n0=t0*t0*(this.grad3[gi0]*x0+this.grad3[gi0+1]*y0+this.grad3[gi0+2]*z0)}let t1=.6-x1*x1-y1*y1-z1*z1;if(t1<0)n1=0;else{t1*=t1;let gi1=3*this.permMod12[ii+i1+this.perm[jj+j1+this.perm[kk+k1]]];n1=t1*t1*(this.grad3[gi1]*x1+this.grad3[gi1+1]*y1+this.grad3[gi1+2]*z1)}let t2=.6-x2*x2-y2*y2-z2*z2;if(t2<0)n2=0;else{t2*=t2;let gi2=3*this.permMod12[ii+i2+this.perm[jj+j2+this.perm[kk+k2]]];n2=t2*t2*(this.grad3[gi2]*x2+this.grad3[gi2+1]*y2+this.grad3[gi2+2]*z2)}let t3=.6-x3*x3-y3*y3-z3*z3;if(t3<0)n3=0;else{t3*=t3;let gi3=3*this.permMod12[ii+1+this.perm[jj+1+this.perm[kk+1]]];n3=t3*t3*(this.grad3[gi3]*x3+this.grad3[gi3+1]*y3+this.grad3[gi3+2]*z3)}return 32*(n0+n1+n2+n3)}},SimplexNoise })();

let simplex;

const controls = {
    size: () => document.querySelector('input[name="size"]:checked').value,
    seaLevel: document.getElementById('seaLevel'),
    desertification: document.getElementById('desertification'),
    iceCapLatitude: document.getElementById('iceCapLatitude'),
    seed: document.getElementById('seed'),
    generateBtn: document.getElementById('generateBtn'),
    randomSeedBtn: document.getElementById('randomSeedBtn'),
    downloadColorBtn: document.getElementById('downloadColorBtn'),
    downloadHeightBtn: document.getElementById('downloadHeightBtn'),
};

const displays = {
    seaLevelValue: document.getElementById('seaLevelValue'),
    desertificationValue: document.getElementById('desertificationValue'),
    iceCapLatitudeValue: document.getElementById('iceCapLatitudeValue'),
    status: document.getElementById('status'),
};

const canvas = document.getElementById('planetCanvas');
const ctx = canvas.getContext('2d');

let heightMapData, currentSeed;
const textureNames = ['sand', 'grass', 'rock', 'snow', 'ice'];
let textures = {};
let texturesLoaded = false;

// --- Texture Loading ---
function loadTexture(name) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve({ name, img });
        img.onerror = () => reject(`Could not load texture: textures/${name}.png`);
        img.src = `textures/${name}.png`;
    });
}

function processAndStoreTextures(loadedImages) {
    for (const item of loadedImages) {
        const { name, img } = item;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);
        
        textures[name] = {
            width: img.width,
            height: img.height,
            data: tempCtx.getImageData(0, 0, img.width, img.height).data
        };
    }
    texturesLoaded = true;
}

// --- Generator Logic ---
const mapToSphere = (x, y, width, height) => {
    const lon_deg = (x / width) * 360.0;
    const lat_deg = (y / height) * 180.0 - 90.0;
    const lon_rad = (lon_deg * Math.PI) / 180.0;
    const lat_rad = (lat_deg * Math.PI) / 180.0;
    return {
        x: Math.cos(lat_rad) * Math.cos(lon_rad),
        y: Math.cos(lat_rad) * Math.sin(lon_rad),
        z: Math.sin(lat_rad)
    };
};

const generateTerrainMaps = (width, height, seed) => {
    const heightMap = new Float32Array(width * height);
    const moistureMap = new Float32Array(width * height);
    displays.status.textContent = "Generating terrain data...";
    const SCALE = 200.0, OCTAVES = 8, PERSISTENCE = 0.5, LACUNARITY = 2.0;
    const moisture_scale = SCALE * 1.5, moisture_octaves = 4;
    const angle_rad = simplex.random() * 2 * Math.PI;
    const cos_a = Math.cos(angle_rad), sin_a = Math.sin(angle_rad);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const sphereCoords = mapToSphere(x, y, width, height);
            const rotated_sx = sphereCoords.x * cos_a - sphereCoords.y * sin_a;
            const rotated_sy = sphereCoords.x * sin_a + sphereCoords.y * cos_a;
            const rotated_sz = sphereCoords.z;
            let h_val = 0, m_val = 0, freq = 1.0, amp = 1.0, maxAmp = 0;
            for (let i = 0; i < OCTAVES; i++) {
                h_val += simplex.noise3D(rotated_sx*freq*SCALE/100, rotated_sy*freq*SCALE/100, rotated_sz*freq*SCALE/100 + seed) * amp;
                if (i < moisture_octaves) {
                    m_val += simplex.noise3D(rotated_sy*freq*moisture_scale/100+seed+500, rotated_sz*freq*moisture_scale/100+seed+500, rotated_sx*freq*moisture_scale/100+seed+500) * amp;
                }
                maxAmp += amp;
                freq *= LACUNARITY;
                amp *= PERSISTENCE;
            }
            const index = y * width + x;
            heightMap[index] = h_val / maxAmp;
            moistureMap[index] = m_val / maxAmp;
        }
    }
    const normalize = (map) => { let min=Infinity, max=-Infinity; for(let v of map){if(v<min)min=v;if(v>max)max=v;} const range=max-min; if(range===0)return map; for(let i=0;i<map.length;i++)map[i]=(map[i]-min)/range; return map; };
    normalize(heightMap);
    normalize(moistureMap);
    for (let i = 0; i < heightMap.length; i++) heightMap[i] = Math.pow(heightMap[i], 1.5);
    return { heightMap, moistureMap };
};

const generateTexturedMap = (width, height, params, terrainMaps, textures) => {
    const { heightMap, moistureMap } = terrainMaps;
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    displays.status.textContent = "Simulating climate and blending textures...";

    const COLOR_DEEP_WATER = [10, 15, 60], COLOR_SHALLOW_WATER = [15, 20, 65];
    
    const MOUNTAIN_PEAK = Math.min(params.SEA_LEVEL + 0.35, 0.95);

    const warmth_factor = (params.ICE_CAP_LATITUDE - 0.5) / 0.5;
    const SNOW_LINE = (params.SEA_LEVEL + 0.2) * (1 - warmth_factor) + 1.5 * warmth_factor;

    const tex_width = textures.sand.width;
    const tex_height = textures.sand.height;

    function sample(textureName, tx, ty) {
        const tex = textures[textureName];
        const index = (ty * tex.width + tx) * 4;
        return [tex.data[index], tex.data[index + 1], tex.data[index + 2]];
    }
    
    function blend(colorA, colorB, factor) {
        return [
            (1 - factor) * colorA[0] + factor * colorB[0],
            (1 - factor) * colorA[1] + factor * colorB[1],
            (1 - factor) * colorA[2] + factor * colorB[2],
        ];
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = y * width + x;
            const h = heightMap[index];
            const m = moistureMap[index];
            
            const latitude_factor = 1.0 - Math.abs(y - height / 2) / (height / 2);
            let temp = latitude_factor * 0.7 + 0.1;
            if (h > params.SEA_LEVEL) temp -= (h - params.SEA_LEVEL) * 0.5;

            const tx = x % tex_width, ty = y % tex_height;
            let terrain_color = [0, 0, 0];

            if (h < params.SEA_LEVEL) {
                // Below sea level (water)
                const depth_factor = params.SEA_LEVEL > 0 ? h / params.SEA_LEVEL : 0;
                terrain_color = blend(COLOR_DEEP_WATER, COLOR_SHALLOW_WATER, depth_factor);
            } else {
                // Above sea level (land)
                const desert_threshold = params.DESERTIFICATION * 0.7;
                let base_color = sample('grass', tx, ty);

                // Desert blending
                if (m < desert_threshold && temp > 0.4 && h < MOUNTAIN_PEAK * 0.8) {
                    const desert_factor = 1.0 - Math.max(0, Math.min(1, m / desert_threshold));
                    base_color = blend(base_color, sample('sand', tx, ty), desert_factor);
                }
                terrain_color = base_color;

                // --- MODIFIED SAND GENERATION LOGIC ---
                let sand_factor = 0.0;
                if (params.SEA_LEVEL > 0) { // Only generate sand near sea level if sea level exists
                    sand_factor = 1.0 - Math.min(1.0, (h - params.SEA_LEVEL) / 0.03);
                }
                
                if (sand_factor > 0) {
                    terrain_color = blend(terrain_color, sample('sand', tx, ty), sand_factor);
                }
                // --- END MODIFICATION ---
                
                // Rock blending
                const rock_blend_start = params.SEA_LEVEL + 0.2;
                const rock_blend_end = MOUNTAIN_PEAK;
                let rock_factor = 0.0;
                if (h > rock_blend_start) {
                    const denominator = rock_blend_end - rock_blend_start;
                    if (denominator > 0) {
                        rock_factor = (h - rock_blend_start) / denominator;
                        rock_factor = Math.max(0, Math.min(1, rock_factor));
                    }
                }
                if (rock_factor > 0) {
                    terrain_color = blend(terrain_color, sample('rock', tx, ty), rock_factor);
                }

                // Snow blending
                const snow_line_dynamic = SNOW_LINE + (1 - temp) * 0.2;
                const snow_blend_start = snow_line_dynamic - 0.1;
                let snow_factor = 0.0;
                if (h > snow_blend_start) {
                    const denominator = snow_line_dynamic - snow_blend_start;
                    if (denominator > 0) {
                        snow_factor = (h - snow_blend_start) / denominator;
                        snow_factor = Math.max(0, Math.min(1, snow_factor));
                    }
                }
                if (temp < 0.15 || snow_factor > 0) {
                    if (temp < 0.15) snow_factor = 1.0;
                    terrain_color = blend(terrain_color, sample('snow', tx, ty), snow_factor);
                }
            }

            // Ice cap blending
            const abs_latitude_factor = Math.abs(y - height / 2) / (height / 2);
            const ice_cap_edge_noise = (m - 0.5) * 0.1;
            let ice_factor = 0.0;
            // Only apply ice if the iceCapLatitude is not at its max (1.0), which signifies a completely warm planet
            if (params.ICE_CAP_LATITUDE < 1.0 && abs_latitude_factor > params.ICE_CAP_LATITUDE - ice_cap_edge_noise) {
                const blend_range = 0.01;
                ice_factor = (abs_latitude_factor - (params.ICE_CAP_LATITUDE - ice_cap_edge_noise)) / blend_range;
                ice_factor = Math.max(0, Math.min(1, ice_factor));
            }
            let final_color = blend(terrain_color, sample('ice', tx, ty), ice_factor);

            // Center noise (if active)
            if (h >= params.SEA_LEVEL) { // Only apply to land
                const center_x = width / 2;
                const distance_from_center = Math.abs(x - center_x);
                let center_blend_factor = 0.0;
                if (distance_from_center < params.CENTER_NOISE_WIDTH) {
                    center_blend_factor = 1.0 - (distance_from_center / params.CENTER_NOISE_WIDTH);
                }
                if (center_blend_factor > 0) {
                    const sphereCoords = mapToSphere(x, y, width, height);
                    let noise_val=0,freq=1,amp=1,maxAmp=0;
                    for(let i=0;i<4;i++){noise_val+=simplex.noise3D(sphereCoords.x*freq*params.CENTER_NOISE_SCALE,sphereCoords.y*freq*params.CENTER_NOISE_SCALE,sphereCoords.z*freq*params.CENTER_NOISE_SCALE+params.SEED+1e3)*amp;maxAmp+=amp;freq*=2;amp*=.5}
                    noise_val=(noise_val/maxAmp+1)/2;
                    const noise_offset=(noise_val-.5)*2*params.CENTER_NOISE_STRENGTH*255;
                    for(let i=0;i<3;i++)final_color[i]+=noise_offset*center_blend_factor;
                }
            }
            
            const pixelIndex = (y * width + x) * 4;
            data[pixelIndex] = Math.max(0,Math.min(255,final_color[0]));
            data[pixelIndex+1] = Math.max(0,Math.min(255,final_color[1]));
            data[pixelIndex+2] = Math.max(0,Math.min(255,final_color[2]));
            data[pixelIndex+3] = 255;
        }
    }
    return imageData;
};


// --- UI and Event Handling ---
function updateSliderValue(slider, display) {
    display.textContent = parseFloat(slider.value).toFixed(2);
}

function attachSliderEvents() {
    controls.seaLevel.addEventListener('input', () => updateSliderValue(controls.seaLevel, displays.seaLevelValue));
    controls.desertification.addEventListener('input', () => updateSliderValue(controls.desertification, displays.desertificationValue));
    controls.iceCapLatitude.addEventListener('input', () => updateSliderValue(controls.iceCapLatitude, displays.iceCapLatitudeValue));
}

function downloadCanvas(filename, canvasToDownload) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = canvasToDownload.toDataURL("image/png");
    link.click();
}

function drawHeightMap(width, height, heightMap) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(width, height);
    for(let i=0; i<heightMap.length; i++) {
        const val = Math.floor(heightMap[i] * 255);
        const pI = i*4;
        imageData.data[pI]=val; imageData.data[pI+1]=val; imageData.data[pI+2]=val; imageData.data[pI+3]=255;
    }
    tempCtx.putImageData(imageData, 0, 0);
    return tempCanvas;
}

function main() {
    controls.generateBtn.disabled = true;
    controls.downloadColorBtn.disabled = true;
    controls.downloadHeightBtn.disabled = true;

    const width = parseInt(controls.size(), 10);
    const height = width / 2;
    canvas.width = width;
    canvas.height = height;
    
    currentSeed = parseInt(controls.seed.value) || Math.floor(Math.random() * 99999);
    controls.seed.value = currentSeed;
    simplex = new SimplexNoise(currentSeed.toString());

    const params = {
        SEED: currentSeed,
        SEA_LEVEL: parseFloat(controls.seaLevel.value),
        DESERTIFICATION: parseFloat(controls.desertification.value),
        ICE_CAP_LATITUDE: parseFloat(controls.iceCapLatitude.value),
        CENTER_NOISE_WIDTH: parseFloat(document.querySelector('input[name=size]:checked').dataset.centerWidth),
        CENTER_NOISE_STRENGTH: 0.0, // Disabled this feature as it's not needed with texture loading
        CENTER_NOISE_SCALE: 0.0
    };

    setTimeout(() => {
        const terrainMaps = generateTerrainMaps(width, height, params.SEED);
        heightMapData = terrainMaps.heightMap;

        if (texturesLoaded) {
            const texturedMapImageData = generateTexturedMap(width, height, params, terrainMaps, textures);
            ctx.putImageData(texturedMapImageData, 0, 0);
        } else {
            // Fallback for local testing without a server
            displays.status.textContent = `Error: Textures not loaded. Displaying solid colors.`;
            // You would need a generateColorMap function here for a true fallback.
        }

        displays.status.textContent = `Done! (Seed: ${params.SEED})`;
        controls.generateBtn.disabled = false;
        controls.downloadColorBtn.disabled = false;
        controls.downloadHeightBtn.disabled = false;
    }, 10);
}

// --- Initial Setup ---
document.addEventListener('DOMContentLoaded', () => {
    attachSliderEvents();
    document.getElementById('size1k').dataset.centerWidth = "20";
    document.getElementById('size2k').dataset.centerWidth = "40";

    controls.randomSeedBtn.addEventListener('click', () => {
        controls.seed.value = Math.floor(Math.random() * 99999);
    });
    controls.generateBtn.addEventListener('click', main);
    controls.downloadColorBtn.addEventListener('click', () => downloadCanvas(`planet_texture_${currentSeed}.png`, canvas));
    controls.downloadHeightBtn.addEventListener('click', () => {
        if (heightMapData) {
            displays.status.textContent = "Preparing heightmap...";
            setTimeout(() => {
                const heightMapCanvas = drawHeightMap(canvas.width, canvas.height, heightMapData);
                downloadCanvas(`planet_heightmap_${currentSeed}.png`, heightMapCanvas);
                displays.status.textContent = `Done! (Seed: ${currentSeed})`;
            }, 10);
        }
    });

    // --- Start Texture Loading Process ---
    displays.status.textContent = "Loading textures...";
    Promise.all(textureNames.map(loadTexture))
        .then(loadedImages => {
            processAndStoreTextures(loadedImages);
            displays.status.textContent = "Textures loaded. Ready to generate.";
            controls.generateBtn.disabled = false;
            controls.randomSeedBtn.click();
            main();
        })
        .catch(error => {
            console.error(error);
            displays.status.textContent = `Error: ${error}. Check textures folder.`;
            alert(`Texture loading failed: ${error}\n\nPlease ensure a 'textures' folder with the required .png files exists in the same directory as this HTML file.`);
        });
});

</script>
</body>
</html>
